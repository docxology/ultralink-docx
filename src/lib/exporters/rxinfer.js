/**
 * RxInferExporter - Export UltraLink knowledge graph to RxInfer.jl model
 * 
 * This module exports UltraLink knowledge graphs to Julia code using the RxInfer.jl
 * @model macro syntax, enabling Bayesian inference via factor graphs.
 */

class RxInferExporter {
  /**
   * Create a new RxInfer.jl exporter
   * @param {UltraLink} ultralink - The UltraLink instance
   */
  constructor(ultralink) {
    this.ultralink = ultralink;
  }

  /**
   * Export UltraLink to RxInfer.jl model
   * @param {Object} options - Export options
   * @param {boolean} options.includeComments - Whether to include descriptive comments (default: true)
   * @param {boolean} options.includeVectors - Whether to include vector representations (default: false)
   * @param {string} options.modelName - Name for the generated RxInfer model (default: 'ultralink_model')
   * @param {Object} options.distributionMapping - Mapping from entity types to distributions
   * @param {boolean} options.includeConstraints - Whether to include variational constraints (default: false)
   * @param {boolean} options.includeTestScript - Whether to generate a test script (default: false)
   * @param {boolean} options.prettyPrint - Format output for readability (default: true)
   * @returns {string} RxInfer.jl model code
   */
  export(options = {}) {
    try {
      // Default options
      const {
        includeComments = true,
        includeVectors = false,
        modelName = 'ultralink_model',
        distributionMapping = {},
        includeConstraints = false,
        includeTestScript = false,
        prettyPrint = true,
        // For backward compatibility
        useConstraints,
        generateTest
      } = options;

      // Determine if we should include constraints (check both old and new option names)
      const shouldIncludeConstraints = includeConstraints || useConstraints || false;
      
      // Determine if we should generate test script (check both old and new option names)
      const shouldIncludeTestScript = includeTestScript || generateTest || false;

      // Get entities and relationships
      const entities = Array.from(this.ultralink.entities.values());
      const relationships = this._extractRelationships();

      // Generate the model code
      const modelCode = this._generateModelCode(
        entities, 
        relationships, 
        modelName, 
        distributionMapping,
        includeComments,
        includeVectors
      );

      // Generate constraints if requested
      const constraintsCode = shouldIncludeConstraints ? 
        this._generateConstraintsCode(entities, relationships, modelName) : '';

      // Generate test code if requested
      const testCode = shouldIncludeTestScript ?
        this._generateTestCode(modelName, entities, relationships) : '';

      // Combine all code sections
      let fullCode = [
        this._generateHeader(modelName, includeComments),
        modelCode
      ];

      if (constraintsCode) {
        fullCode.push(constraintsCode);
      }

      if (testCode) {
        fullCode.push(testCode);
      }

      // Format and return
      return fullCode.join('\n\n');
    } catch (error) {
      throw new Error(`RxInfer.jl export failed: ${error.message}`);
    }
  }

  /**
   * Extract relationships from UltraLink
   * @private
   * @returns {Array} Relationship objects
   */
  _extractRelationships() {
    const relationships = [];
    
    for (const [sourceId, targets] of this.ultralink.links.entries()) {
      for (const [targetId, rel] of targets.entries()) {
        relationships.push({
          source: sourceId,
          target: targetId,
          type: rel.type,
          attributes: rel.attributes || {},
          metadata: rel.metadata || {}
        });
      }
    }
    
    return relationships;
  }

  /**
   * Generate header for the Julia file
   * @private
   * @param {string} modelName - Name of the model
   * @param {boolean} includeComments - Whether to include comments
   * @returns {string} Generated header code
   */
  _generateHeader(modelName, includeComments) {
    const timestamp = new Date().toISOString();
    let header = '';

    if (includeComments) {
      header += `# ${modelName}.jl\n`;
      header += `# Generated by UltraLink on ${timestamp}\n`;
      header += `# This file contains a RxInfer.jl model generated from an UltraLink knowledge graph\n`;
      header += `\n`;
    }

    header += `using RxInfer, Distributions\n`;
    
    return header;
  }

  /**
   * Generate the RxInfer model code
   * @private
   * @param {Array} entities - List of entities
   * @param {Array} relationships - List of relationships
   * @param {string} modelName - Name of the model
   * @param {Object} distributionMapping - Type to distribution mapping
   * @param {boolean} includeComments - Whether to include comments
   * @param {boolean} includeVectors - Whether to include vectors
   * @returns {string} Generated model code
   */
  _generateModelCode(
    entities, 
    relationships, 
    modelName, 
    distributionMapping,
    includeComments,
    includeVectors
  ) {
    let code = '';

    // Start model definition
    code += `@model function ${modelName}()\n`;
    
    if (includeComments) {
      code += `    # Define variables for entities\n`;
    }

    // Add entity variable declarations
    for (const entity of entities) {
      const distribution = this._getDistributionForEntity(entity, distributionMapping);
      const varName = this._sanitizeVariableName(entity.id);
      
      if (includeComments) {
        code += `    # Entity: ${entity.id} (type: ${entity.type})\n`;
      }
      
      code += `    ${varName} ~ ${distribution}\n`;
      
      // Add attributes as separate variables if they contain useful information
      if (entity.attributes && Object.keys(entity.attributes).length > 0) {
        for (const [key, value] of Object.entries(entity.attributes)) {
          // Skip attributes that don't make sense as variables
          if (
            typeof value === 'string' && value.length > 20 || 
            key === 'name' || 
            key === 'description'
          ) continue;
          
          // Create variable for meaningful attributes
          if (this._isUsefulAttribute(key, value)) {
            const attrVarName = this._sanitizeVariableName(`${entity.id}_${key}`);
            const attrDist = this._getDistributionForAttribute(key, value);
            code += `    ${attrVarName} ~ ${attrDist}\n`;
          }
        }
      }
      
      // Add vector if requested and available
      if (includeVectors && entity.vector && entity.vector.length > 0) {
        const vecVarName = this._sanitizeVariableName(`${entity.id}_vec`);
        const vecDist = this._getDistributionForVector(entity.vector);
        code += `    ${vecVarName} ~ ${vecDist}\n`;
      }
    }
    
    if (includeComments && relationships.length > 0) {
      code += `\n    # Define relationships between variables\n`;
    }
    
    // Add relationship dependencies
    for (const rel of relationships) {
      const sourceVar = this._sanitizeVariableName(rel.source);
      const targetVar = this._sanitizeVariableName(rel.target);
      const relType = rel.type;
      
      // Skip self-relations
      if (rel.source === rel.target) continue;
      
      if (includeComments) {
        code += `    # Relationship: ${rel.source} (${relType}) ${rel.target}\n`;
      }
      
      // Create conditional dependency based on relationship type
      const conditional = this._getConditionalForRelationship(relType, sourceVar, targetVar);
      code += `    ${conditional}\n`;
      
      // Add relationship attributes if useful
      if (rel.attributes && Object.keys(rel.attributes).length > 0) {
        for (const [key, value] of Object.entries(rel.attributes)) {
          if (this._isUsefulAttribute(key, value)) {
            const relAttrVar = this._sanitizeVariableName(`${rel.source}_${relType}_${rel.target}_${key}`);
            const attrDist = this._getDistributionForAttribute(key, value);
            code += `    ${relAttrVar} ~ ${attrDist}\n`;
          }
        }
      }
    }
    
    // End function and return variables of interest
    code += `\n    # Return variables of interest\n`;
    code += `    return (${entities.map(e => this._sanitizeVariableName(e.id)).join(', ')})\n`;
    code += `end`;
    
    return code;
  }
  
  /**
   * Generate constraints code for the model
   * @private
   * @param {Array} entities - List of entities
   * @param {Array} relationships - List of relationships
   * @param {string} modelName - Name of the model
   * @returns {string} Generated constraints code
   */
  _generateConstraintsCode(entities, relationships, modelName) {
    let code = `@constraints function ${modelName}_constraints()\n`;
    
    // Add mean-field factorization
    code += `    # Mean-field factorization\n`;
    
    // Get all variable names
    const varNames = entities.map(e => this._sanitizeVariableName(e.id));
    
    if (varNames.length > 0) {
      code += `    q(${varNames.join(', ')}) = ${varNames.map(v => `q(${v})`).join('')}\n`;
    }
    
    // Add distribution family constraints
    code += `\n    # Distribution family constraints\n`;
    
    for (const entity of entities) {
      const varName = this._sanitizeVariableName(entity.id);
      const family = this._getDistributionFamily(entity.type);
      code += `    q(${varName}) :: ${family}\n`;
    }
    
    code += `end`;
    return code;
  }
  
  /**
   * Generate test code for the model
   * @private
   * @param {string} modelName - Name of the model
   * @param {Array} entities - List of entities
   * @param {Array} relationships - List of relationships
   * @returns {string} Generated test code
   */
  _generateTestCode(modelName, entities, relationships) {
    let code = `# Test script for ${modelName}\n\n`;
    
    code += `function test_${modelName}()\n`;
    code += `    # Create the model\n`;
    code += `    model = ${modelName}()\n\n`;
    
    code += `    # Run inference\n`;
    code += `    result = infer(\n`;
    code += `        model = model,\n`;
    
    if (entities.length > 0) {
      // Create sample data
      code += `        data = (\n`;
      for (const entity of entities.slice(0, 3)) { // Just use a few entities for the example
        const varName = this._sanitizeVariableName(entity.id);
        code += `            ${varName} = rand(${this._getTestDistribution(entity.type)}),\n`;
      }
      code += `        )\n`;
    } else {
      code += `        data = ()\n`;
    }
    
    code += `    )\n\n`;
    
    code += `    # Access posterior distributions\n`;
    if (entities.length > 0) {
      for (const entity of entities.slice(0, 3)) {
        const varName = this._sanitizeVariableName(entity.id);
        code += `    posterior_${varName} = result.posteriors[:${varName}]\n`;
      }
    }
    
    code += `\n    return result\n`;
    code += `end\n\n`;
    
    code += `# Run the test\n`;
    code += `test_${modelName}()`;
    
    return code;
  }
  
  /**
   * Get appropriate distribution for entity based on type
   * @private
   * @param {Object} entity - Entity object
   * @param {Object} distributionMapping - Custom mapping from types to distributions
   * @returns {string} Distribution code
   */
  _getDistributionForEntity(entity, distributionMapping) {
    // Check custom mapping first
    if (distributionMapping[entity.type]) {
      return distributionMapping[entity.type];
    }
    
    // Default mappings based on entity type
    switch (entity.type.toLowerCase()) {
      case 'person':
      case 'user':
      case 'customer':
        return 'Categorical([0.5, 0.5])'; // Binary presence/absence
        
      case 'event':
      case 'action':
      case 'activity':
        return 'Bernoulli(0.5)'; // Binary occurred/not occurred
        
      case 'concept':
      case 'idea':
      case 'topic':
        return 'Dirichlet([1.0, 1.0, 1.0])'; // Categorical distribution with 3 options
        
      case 'location':
      case 'place':
        return 'MvNormal(zeros(2), I)'; // 2D location
        
      case 'measurement':
      case 'observation':
      case 'reading':
      case 'score':
        return 'Normal(0.0, 1.0)'; // Continuous value
        
      case 'probability':
      case 'rate':
      case 'percentage':
        return 'Beta(1.0, 1.0)'; // Value between 0-1
        
      case 'count':
      case 'frequency':
        return 'Poisson(1.0)'; // Non-negative integer
        
      default:
        // For unknown types, try to infer from attributes
        if (this._hasNumericAttributes(entity)) {
          return 'Normal(0.0, 1.0)';
        } else if (this._hasBooleanAttributes(entity)) {
          return 'Bernoulli(0.5)';
        } else {
          return 'Categorical([0.33, 0.33, 0.34])'; // Default to categorical
        }
    }
  }
  
  /**
   * Get appropriate distribution for attribute
   * @private
   * @param {string} key - Attribute key
   * @param {*} value - Attribute value
   * @returns {string} Distribution code
   */
  _getDistributionForAttribute(key, value) {
    // Infer distribution from value type
    if (typeof value === 'number') {
      if (value >= 0 && value <= 1) {
        return 'Beta(1.0, 1.0)';
      } else if (Number.isInteger(value) && value >= 0) {
        return 'Poisson(1.0)';
      } else {
        return 'Normal(0.0, 1.0)';
      }
    } else if (typeof value === 'boolean') {
      return 'Bernoulli(0.5)';
    } else if (Array.isArray(value)) {
      return `Dirichlet(ones(${Math.min(value.length, 3)}))`;
    } else {
      return 'Categorical([0.5, 0.5])';
    }
  }
  
  /**
   * Get appropriate distribution for a vector
   * @private
   * @param {Array} vector - Vector array
   * @returns {string} Distribution code
   */
  _getDistributionForVector(vector) {
    const dim = vector.length;
    return `MvNormal(zeros(${dim}), I)`;
  }
  
  /**
   * Get conditional expression for relationship
   * @private
   * @param {string} relType - Relationship type
   * @param {string} sourceVar - Source variable name
   * @param {string} targetVar - Target variable name
   * @returns {string} Conditional code
   */
  _getConditionalForRelationship(relType, sourceVar, targetVar) {
    // Map relationship types to conditional distributions
    switch (relType.toLowerCase()) {
      case 'causes':
      case 'influences':
      case 'affects':
      case 'impacts':
        return `${targetVar} ~ Normal(${sourceVar}, exp(-${sourceVar}))`;
        
      case 'contains':
      case 'includes':
      case 'has_part':
        return `${targetVar} ~ Bernoulli(sigmoid(${sourceVar}))`;
        
      case 'related_to':
      case 'connected_to':
      case 'associated_with':
      case 'linked_to':
        return `${targetVar} ~ Normal(0.5 * ${sourceVar}, 1.0)`;
        
      case 'depends_on':
      case 'requires':
      case 'needs':
        return `${targetVar} ~ Bernoulli(sigmoid(2.0 * ${sourceVar}))`;
        
      case 'precedes':
      case 'follows':
      case 'before':
      case 'after':
        return `${targetVar} ~ Poisson(exp(${sourceVar}))`;
        
      // Add more relationship mappings as needed
        
      default:
        // Default to simple normal relationship
        return `${targetVar} ~ Normal(0.1 * ${sourceVar}, 1.0)`;
    }
  }
  
  /**
   * Get distribution family for constraints
   * @private
   * @param {string} entityType - Entity type
   * @returns {string} Distribution family name
   */
  _getDistributionFamily(entityType) {
    // Map entity types to distribution families for constraints
    switch (entityType.toLowerCase()) {
      case 'person':
      case 'user':
      case 'event':
      case 'action':
        return 'Categorical';
        
      case 'measurement':
      case 'observation':
      case 'score':
        return 'NormalMeanPrecision';
        
      case 'probability':
      case 'rate':
      case 'percentage':
        return 'Beta';
        
      case 'count':
      case 'frequency':
        return 'Gamma';
        
      default:
        return 'ExponentialFamily';
    }
  }
  
  /**
   * Get test distribution for a given entity type
   * @private
   * @param {string} entityType - Entity type
   * @returns {string} Distribution for test data
   */
  _getTestDistribution(entityType) {
    // Simplified distributions for test data generation
    switch (entityType.toLowerCase()) {
      case 'person':
      case 'user':
      case 'customer':
        return 'Categorical([0.5, 0.5])';
        
      case 'event':
      case 'action':
      case 'activity':
        return 'Bernoulli(0.5)';
        
      case 'concept':
      case 'idea':
      case 'topic':
        return 'Categorical([0.33, 0.33, 0.34])';
        
      case 'measurement':
      case 'observation':
      case 'reading':
      case 'score':
        return 'Normal(0.0, 1.0)';
        
      default:
        return 'Normal(0.0, 1.0)';
    }
  }
  
  /**
   * Sanitize an ID to a valid Julia variable name
   * @private
   * @param {string} id - Entity or relationship ID
   * @returns {string} Valid Julia variable name
   */
  _sanitizeVariableName(id) {
    // Replace invalid characters with underscores
    return id
      .replace(/[^a-zA-Z0-9_]/g, '_')
      .replace(/^[^a-zA-Z_]/, '_$&'); // Ensure starts with letter or underscore
  }
  
  /**
   * Check if an attribute is useful for the model
   * @private
   * @param {string} key - Attribute key
   * @param {*} value - Attribute value
   * @returns {boolean} Whether attribute is useful
   */
  _isUsefulAttribute(key, value) {
    // Skip common metadata and descriptive fields
    const skipKeys = [
      'name', 'description', 'label', 'comment', 'notes',
      'created', 'modified', 'timestamp', 'id', 'source', 'target'
    ];
    
    if (skipKeys.includes(key.toLowerCase())) {
      return false;
    }
    
    // Skip very long text values
    if (typeof value === 'string' && value.length > 50) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Check if entity has numeric attributes
   * @private
   * @param {Object} entity - Entity object
   * @returns {boolean} Whether entity has numeric attributes
   */
  _hasNumericAttributes(entity) {
    if (!entity.attributes) return false;
    
    return Object.values(entity.attributes).some(value => 
      typeof value === 'number'
    );
  }
  
  /**
   * Check if entity has boolean attributes
   * @private
   * @param {Object} entity - Entity object
   * @returns {boolean} Whether entity has boolean attributes
   */
  _hasBooleanAttributes(entity) {
    if (!entity.attributes) return false;
    
    return Object.values(entity.attributes).some(value => 
      typeof value === 'boolean'
    );
  }
}

module.exports = RxInferExporter; 