/**
 * HTML Website Exporter
 * 
 * Specialized exporter for generating a modern, interactive HTML website
 * from UltraLink entities. Includes features like:
 * - Responsive design with modern CSS
 * - Interactive graph visualization
 * - Full-text search
 * - Type-based filtering
 * - Relationship exploration
 */

const { SpecializedExporter } = require('../base');
const path = require('path');
const fs = require('fs');

/**
 * Specialized exporter for HTML websites
 */
class HTMLWebsiteExporter extends SpecializedExporter {
  /**
   * @param {Object} store - The UltraLink entity store
   * @param {Object} options - Configuration options
   * @param {String} options.outputPath - Directory to output website files
   * @param {String} options.siteTitle - Title of the website
   * @param {String} options.theme - Theme to use ('light', 'dark', 'auto')
   * @param {Boolean} options.includeSearch - Whether to include search functionality
   * @param {Boolean} options.includeGraph - Whether to include relationship graph
   * @param {Object} options.customStyles - Custom CSS styles to include
   */
  constructor(store, options = {}) {
    super(store, options);
    this.title = options.title || 'UltraLink Visualization';
    this.description = options.description || 'Interactive visualization of UltraLink data';
    this.theme = options.theme || 'light';
    this.features = {
      search: options.features?.search ?? true,
      filter: options.features?.filter ?? true,
      graph: options.features?.graph ?? true,
      darkMode: options.features?.darkMode ?? true
    };
    this.customStyles = options.customStyles || {};
  }

  /**
   * Generate the main HTML template
   * @param {String} content - Content to insert into template
   * @param {String} title - Page title
   * @returns {String} - Complete HTML document
   */
  generateTemplate(content, title) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title} - ${this.title}</title>
    <link rel="stylesheet" href="/styles/main.css">
    ${this.features.graph ? '<script src="https://d3js.org/d3.v7.min.js"></script>' : ''}
    ${this.features.search ? '<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>' : ''}
    <script src="/js/main.js" defer></script>
    ${this.features.darkMode ? '<link rel="stylesheet" href="/styles/dark-mode.css" disabled>' : ''}
</head>
<body class="theme-${this.theme}">
    <nav class="main-nav">
        <div class="nav-brand">
            <a href="/">${this.title}</a>
        </div>
        <div class="nav-links">
            <a href="/index.html">Home</a>
            <a href="/entities/index.html">Entities</a>
            <a href="/types/index.html">Types</a>
            ${this.features.graph ? '<a href="/graph.html">Graph</a>' : ''}
        </div>
        ${this.features.search ? `
        <div class="search-container">
            <input type="text" id="search" placeholder="Search...">
            <div id="search-results" class="search-results"></div>
        </div>` : ''}
        ${this.features.darkMode ? '<button id="theme-toggle">Toggle Theme</button>' : ''}
    </nav>
    
    <main class="content">
        ${content}
    </main>
    
    <footer>
        <p>Generated by UltraLink HTML Website Exporter</p>
        <p>Last updated: ${new Date().toISOString()}</p>
    </footer>
</body>
</html>`;
  }

  /**
   * Generate CSS styles
   * @returns {String} - CSS content
   */
  generateStyles() {
    return `/* Base styles */
:root {
    --primary-color: #2563eb;
    --secondary-color: #3b82f6;
    --text-color: #1f2937;
    --bg-color: #ffffff;
    --nav-bg: #f3f4f6;
    --card-bg: #ffffff;
    --border-color: #e5e7eb;
}

[data-theme="dark"] {
    --primary-color: #60a5fa;
    --secondary-color: #3b82f6;
    --text-color: #f3f4f6;
    --bg-color: #111827;
    --nav-bg: #1f2937;
    --card-bg: #1f2937;
    --border-color: #374151;
}

body {
    font-family: system-ui, -apple-system, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
    background: var(--bg-color);
    margin: 0;
    padding: 0;
}

.main-nav {
    background: var(--nav-bg);
    padding: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.nav-brand a {
    font-size: 1.25rem;
    font-weight: bold;
    color: var(--primary-color);
    text-decoration: none;
}

.nav-links a {
    color: var(--text-color);
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    transition: background-color 0.2s;
}

.nav-links a:hover {
    background-color: var(--border-color);
}

.content {
    max-width: 1200px;
    margin: 2rem auto;
    padding: 0 1rem;
}

.card {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    padding: 1.5rem;
    margin-bottom: 1rem;
}

.entity-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.search-container {
    position: relative;
    width: 300px;
}

#search {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 0.375rem;
    background: var(--bg-color);
    color: var(--text-color);
}

.search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 0.375rem;
    margin-top: 0.5rem;
    max-height: 400px;
    overflow-y: auto;
    display: none;
}

.search-results.active {
    display: block;
}

.search-result-item {
    padding: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}

.search-result-item:hover {
    background: var(--nav-bg);
}

.graph-container {
    width: 100%;
    height: 600px;
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    overflow: hidden;
}

/* Custom styles from options */
${Object.entries(this.customStyles).map(([selector, rules]) => 
  `${selector} {
    ${Object.entries(rules).map(([prop, value]) => `${prop}: ${value};`).join('\n    ')}
  }`
).join('\n\n')}`;
  }

  /**
   * Generate JavaScript for interactive features
   * @returns {String} - JavaScript content
   */
  generateJavaScript() {
    return `// Main JavaScript for UltraLink website
document.addEventListener('DOMContentLoaded', function() {
    // Theme handling
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const theme = localStorage.getItem('theme') || '${this.theme}';
    
    function updateTheme(theme) {
        if (theme === 'auto') {
            document.body.classList.toggle('theme-dark', prefersDark.matches);
        } else {
            document.body.classList.toggle('theme-dark', theme === 'dark');
        }
    }
    
    updateTheme(theme);
    prefersDark.addListener(() => updateTheme(theme));
    
    ${this.features.search ? this.generateSearchJS() : ''}
    ${this.features.graph ? this.generateGraphJS() : ''}
});`;
  }

  /**
   * Generate JavaScript for search functionality
   * @returns {String} - Search-related JavaScript
   */
  generateSearchJS() {
    return `
    // Search functionality
    const searchData = ${JSON.stringify(Array.from(this.store.entities.values()).map(entity => ({
      id: entity.id,
      title: entity.attributes.title || entity.attributes.name || entity.id,
      type: entity.type,
      description: entity.attributes.description || '',
      content: entity.attributes.content || ''
    })))};
    
    const searchOptions = {
      keys: ['title', 'description', 'content'],
      threshold: 0.3
    };
    
    const fuse = new Fuse(searchData, searchOptions);
    const searchInput = document.getElementById('search');
    const searchResults = document.getElementById('search-results');
    
    searchInput.addEventListener('input', function(e) {
        const value = e.target.value;
        if (value.length < 2) {
            searchResults.classList.remove('active');
            return;
        }
        
        const results = fuse.search(value);
        searchResults.innerHTML = results
            .slice(0, 10)
            .map(result => \`
                <div class="search-result-item" onclick="window.location.href='/entities/\${result.item.id}.html'">
                    <strong>\${result.item.title}</strong>
                    <div>\${result.item.type}</div>
                    <small>\${result.item.description.slice(0, 100)}...</small>
                </div>
            \`).join('');
        
        searchResults.classList.add('active');
    });
    
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('active');
        }
    });`;
  }

  /**
   * Generate JavaScript for graph visualization
   * @returns {String} - Graph-related JavaScript
   */
  generateGraphJS() {
    const graphData = {
      nodes: Array.from(this.store.entities.values()).map(entity => ({
        id: entity.id,
        group: entity.type,
        label: entity.attributes.name || entity.attributes.title || entity.id
      })),
      links: Array.from(this.store.entities.values()).flatMap(entity =>
        this.store.getRelationships(entity.id).map(rel => ({
          source: rel.source,
          target: rel.target,
          type: rel.type
        }))
      )
    };

    return `
// Graph visualization
const graphData = ${JSON.stringify(graphData)};

function initializeGraph() {
  const container = document.getElementById('graph');
  if (!container) return;

  const width = container.clientWidth;
  const height = container.clientHeight;

  const svg = d3.select(container)
    .append('svg')
    .attr('width', width)
    .attr('height', height);

  const simulation = d3.forceSimulation(graphData.nodes)
    .force('link', d3.forceLink(graphData.links).id(d => d.id))
    .force('charge', d3.forceManyBody().strength(-100))
    .force('center', d3.forceCenter(width / 2, height / 2));

  const link = svg.append('g')
    .selectAll('line')
    .data(graphData.links)
    .join('line')
    .attr('stroke', '#999')
    .attr('stroke-opacity', 0.6);

  const node = svg.append('g')
    .selectAll('circle')
    .data(graphData.nodes)
    .join('circle')
    .attr('r', 5)
    .attr('fill', d => getNodeColor(d))
    .call(drag(simulation));

  node.append('title')
    .text(d => d.label);

  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);
  });
}

function getNodeColor(node) {
  const colors = {
    researcher: '#4a6fa5',
    project: '#57a773',
    publication: '#ef8354'
  };
  return colors[node.group] || '#999';
}

function drag(simulation) {
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  return d3.drag()
    .on('start', dragstarted)
    .on('drag', dragged)
    .on('end', dragended);
}

// Initialize graph when DOM is ready
document.addEventListener('DOMContentLoaded', initializeGraph);`;
  }

  /**
   * Generate entity page HTML
   * @param {Object} entity - Entity to generate page for
   * @returns {String} - HTML content
   */
  generateEntityPage(entity) {
    const title = entity.attributes.title || entity.attributes.name || entity.id;
    const description = entity.attributes.description || '';
    const content = entity.attributes.content || '';
    
    const relatedEntities = Array.from(this.store.entities.values())
      .filter(other => 
        other.id !== entity.id && 
        (other.links.some(link => link.target === entity.id) ||
         entity.links.some(link => link.target === other.id))
      );

    const pageContent = `
      <article class="entity-page">
        <header>
          <h1>${title}</h1>
          <div class="entity-meta">
            <span class="entity-type">${entity.type}</span>
            <span class="entity-id">ID: ${entity.id}</span>
          </div>
        </header>

        ${description ? `
        <section class="entity-description">
          <h2>Description</h2>
          <p>${description}</p>
        </section>` : ''}

        ${content ? `
        <section class="entity-content">
          <h2>Content</h2>
          <div class="content-body">
            ${content}
          </div>
        </section>` : ''}

        <section class="entity-attributes">
          <h2>Attributes</h2>
          <dl>
            ${Object.entries(entity.attributes)
              .filter(([key]) => !['title', 'name', 'description', 'content'].includes(key))
              .map(([key, value]) => `
                <dt>${key}</dt>
                <dd>${JSON.stringify(value)}</dd>
              `).join('')}
          </dl>
        </section>

        <section class="entity-relationships">
          <h2>Relationships</h2>
          <div class="relationships-outgoing">
            <h3>Outgoing Links</h3>
            <ul>
              ${entity.links.map(link => `
                <li>
                  <a href="/entities/${link.target}.html">
                    ${this.store.entities.get(link.target)?.attributes.title || link.target}
                  </a>
                  <span class="relationship-type">${link.type}</span>
                </li>
              `).join('')}
            </ul>
          </div>

          <div class="relationships-incoming">
            <h3>Incoming Links</h3>
            <ul>
              ${relatedEntities
                .filter(other => other.links.some(link => link.target === entity.id))
                .map(other => `
                  <li>
                    <a href="/entities/${other.id}.html">
                      ${other.attributes.title || other.attributes.name || other.id}
                    </a>
                    <span class="relationship-type">
                      ${other.links.find(link => link.target === entity.id).type}
                    </span>
                  </li>
                `).join('')}
            </ul>
          </div>
        </section>
      </article>`;

    return this.generateTemplate(pageContent, title);
  }

  /**
   * Generate index page HTML
   * @returns {String} - HTML content
   */
  generateIndexPage() {
    const entityTypes = new Set();
    for (const entity of this.store.entities.values()) {
      entityTypes.add(entity.type);
    }

    const pageContent = `
      <div class="home-page">
        <header class="page-header">
          <h1>${this.title}</h1>
          <p>${this.description}</p>
        </header>

        <section class="overview">
          <h2>Overview</h2>
          <div class="stats-grid">
            <div class="stat-card">
              <h3>Total Entities</h3>
              <div class="stat-value">${this.store.entities.size}</div>
            </div>
            <div class="stat-card">
              <h3>Entity Types</h3>
              <div class="stat-value">${entityTypes.size}</div>
            </div>
            <div class="stat-card">
              <h3>Total Relationships</h3>
              <div class="stat-value">
                ${Array.from(this.store.entities.values())
                  .reduce((sum, entity) => sum + entity.links.length, 0)}
              </div>
            </div>
          </div>
        </section>

        <section class="entity-types">
          <h2>Entity Types</h2>
          <div class="type-grid">
            ${Array.from(entityTypes).map(type => `
              <div class="type-card">
                <h3>${type}</h3>
                <p>
                  ${Array.from(this.store.entities.values())
                    .filter(entity => entity.type === type).length} entities
                </p>
                <a href="/types/${type}.html" class="button">View All</a>
              </div>
            `).join('')}
          </div>
        </section>

        ${this.features.graph ? `
        <section class="graph-overview">
          <h2>Relationship Graph</h2>
          <div class="graph-container"></div>
        </section>` : ''}
      </div>`;

    return this.generateTemplate(pageContent, 'Home');
  }

  /**
   * Export all entities as a website
   * @returns {Object} Map of filenames to content
   */
  exportAll() {
    try {
      const output = {};

      // Generate main files
      output['index.html'] = this.generateIndexPage();
      output['css/main.css'] = this.generateStyles();
      output['js/main.js'] = this.generateJavaScript();

      if (this.features.darkMode) {
        output['css/dark-mode.css'] = this.generateDarkModeStyles();
      }

      // Generate entity pages
      const entities = this.filterEntities();
      for (const entity of entities) {
        output[`entities/${entity.id}.html`] = this.generateEntityPage(entity);
      }

      // Generate data files
      output['data/entities.json'] = JSON.stringify(
        entities,
        null,
        2
      );

      output['data/relationships.json'] = JSON.stringify(
        entities.flatMap(entity =>
          this.store.getRelationships(entity.id)
        ),
        null,
        2
      );

      // Write files if outputPath is specified
      if (this.options.outputPath) {
        for (const [filename, content] of Object.entries(output)) {
          this.writeOutput(content, filename);
        }
      }

      return output;
    } catch (error) {
      console.error('Error generating website:', error);
      return false;
    }
  }

  /**
   * Export a single entity as an HTML page
   * @param {String} entityId - ID of entity to export
   * @returns {String} - HTML content
   */
  exportEntity(entityId) {
    const entity = this.store.entities.get(entityId);
    
    if (!entity) {
      throw new Error(`Entity with ID "${entityId}" not found`);
    }
    
    return this.generateEntityPage(entity);
  }

  /**
   * Get information about what this exporter does
   * @returns {Object} - Information about the exporter
   */
  getInfo() {
    return {
      name: 'HTMLWebsiteExporter',
      description: 'Exports entities as an interactive HTML website',
      outputFormats: ['HTML, CSS, JavaScript'],
      supportedOptions: {
        outputPath: 'Directory to output website files',
        siteTitle: 'Title of the website',
        theme: 'Theme to use (light, dark, auto)',
        includeSearch: 'Whether to include search functionality',
        includeGraph: 'Whether to include relationship graph',
        customStyles: 'Custom CSS styles to include'
      }
    };
  }

  /**
   * Generate dark mode styles
   * @returns {string} CSS content
   */
  generateDarkModeStyles() {
    return `
/* Dark mode styles */
body.theme-dark {
  --primary-color: #2c4159;
  --secondary-color: #3d7452;
  --text-color: #e1e1e1;
  --bg-color: #1a1a1a;
  --border-color: #333;
  --hover-color: #2a2a2a;
}

body.theme-dark .navbar {
  background-color: #1a1a1a;
  border-bottom: 1px solid var(--border-color);
}

body.theme-dark .entity-card {
  background-color: #2a2a2a;
}

body.theme-dark .graph-container {
  background-color: #2a2a2a;
  border-color: #333;
}`;
  }
}

module.exports = HTMLWebsiteExporter; 